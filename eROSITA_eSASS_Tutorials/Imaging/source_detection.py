import subprocess
import numpy as np
from astropy.io import fits
from astropy import units as u
from astropy import wcs
import os
from tqdm import tqdm
from astropy.coordinates import SkyCoord
import argparse
import logging
import warnings
import time
from concurrent.futures import ProcessPoolExecutor
import sys
start_time = time.time()
warnings.filterwarnings("ignore")

# Parse input arguments
parser = argparse.ArgumentParser(description="Run eSASS tasks for source detection and to create a cheese-mask for point sources.")
parser.add_argument("input_image", type=str, help="Path to the input image file.")
parser.add_argument("input_expmap", type=str, help="Path to the input exposure map file.")
parser.add_argument("output_dir", type=str, help="Directory to save the output files.")
parser.add_argument("PS_size", type=float, default=1, help="Point source extent size in arcmin.")
parser.add_argument("--pts_catalog", type=str, help="Path to the input catalog file. If not provided, the catalog generated by the pipeline will be used.")
parser.add_argument("--ds9", action="store_true", default=False, help="Flag to open the output cheese-mask and region file in DS9. Default is False.")
args = parser.parse_args()

# Input parameters
input_image = args.input_image
input_expmap = args.input_expmap
output_dir = args.output_dir
PS_size = args.PS_size
pts_catalog = args.pts_catalog
open_ds9 = args.ds9

# Set up logging
log_filename = os.path.join(output_dir, "source_detection.log")

if os.path.exists(log_filename):
    os.remove(log_filename)

logging.basicConfig(filename=log_filename, level=logging.INFO, format='%(message)s')
logger = logging.getLogger()

# Add a stream handler to print to console without timestamps
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.INFO)
console_handler.setFormatter(logging.Formatter('%(message)s'))
logger.addHandler(console_handler)

# Log the start date and time
start_datetime = time.strftime("%d-%m-%Y %H:%M:%S", time.localtime(start_time))
logger.info(f'Start date and time: {start_datetime}')
logger.info(f'Command used: python {" ".join(sys.argv)}')
logger.info("\n========================================\n")
logger.info('Setting up the environment...')

output_mask_file = os.path.join(output_dir, "detmask.fits")
output_boxlist_local = os.path.join(output_dir, "boxlist_local.fits")
output_bkgmap = os.path.join(output_dir, "BG_maps", "bkg_map.fits")
output_cheesemask = os.path.join(output_dir, "BG_maps", "cheesemask_all.fits")
output_boxlist_map = os.path.join(output_dir, "boxlist_map.fits")
output_mllist = os.path.join(output_dir, "mllist.fits")
output_sourceimage = os.path.join(output_dir, "sourceimage.fits")
output_catalog = os.path.join(output_dir, "catalog.fits")

# Create necessary directories
os.makedirs(output_dir, exist_ok=True)
os.makedirs(os.path.join(output_dir, "BG_maps"), exist_ok=True)

logger.info('Starting the workflow with the following parameters:')
logger.info(f'    Input image: {input_image}')
logger.info(f'    Input exposure map: {input_expmap}')
logger.info(f'    Output directory: {output_dir}')
logger.info(f'    Point source extent size: {PS_size} arcmin')
if pts_catalog:
    logger.info(f'    Input point source catalog: {pts_catalog}')
else:
    logger.info('    No input point source catalog provided. Using the catalog generated by the pipeline.')
logger.info(f'    Open output cheese-mask and region in DS9 flag: {open_ds9}')
logger.info(f'    Log file: {log_filename}')

########## Defining the functions ##########

# Function to run ermask
def run_ermask(exposure_map, output_mask_file, log_file=None):
    subprocess.run(["ermask", 
                    f"expimage={exposure_map}", 
                    f"detmask={output_mask_file}",
                    ], stdout=log_file, stderr=log_file)

# Function to run erbox
def run_erbox(image_file, exposure_map, detmask_file, output_boxlist, bkg_map=None, bg_image_flag="N", ecf=1, emin=200, emax=2300, log_file=None):
    if bg_image_flag == "N":
        subprocess.run(["erbox", 
                        f"images={image_file}", 
                        f"expimages={exposure_map}",
                        f"detmasks={detmask_file}",
                        f"boxlist={output_boxlist}",
                        f"emin={emin}",
                        f"emax={emax}",
                        f"bkgima_flag={bg_image_flag}",
                        f"ecf={ecf}",
                        ], stdout=log_file, stderr=log_file)
    else:
        subprocess.run(["erbox", 
                        f"images={image_file}", 
                        f"expimages={exposure_map}",
                        f"detmasks={detmask_file}",
                        f"boxlist={output_boxlist}",
                        f"emin={emin}",
                        f"emax={emax}",
                        f"bkgimages={bkg_map}",
                        f"ecf={ecf}",
                        ], stdout=log_file, stderr=log_file)

# Function to run erbackmap
def run_erbackmap(image_file, exposure_map, detmask_file, boxlist_file, output_bkgmap, output_cheesemask, emin=200, emax=2300, log_file=None):
    subprocess.run(["erbackmap", 
                    f"image={image_file}", 
                    f"expimage={exposure_map}",
                    f"detmask={detmask_file}",
                    f"boxlist={boxlist_file}",
                    f"bkgimage={output_bkgmap}",
                    f"cheesemask={output_cheesemask}",
                    f"emax={emax}",
                    "cheesemask_flag=Y",
                    "clobber=Y",
                    ], stdout=log_file, stderr=log_file)

# Function to run ermldet
def run_ermldet(image_file, exposure_map, detmask_file, boxlist_file, bkg_map, output_mllist, output_sourceimage, emin=200, emax=2300, log_file=None):
    subprocess.run(["ermldet", 
                    f"mllist={output_mllist}", 
                    f"boxlist={boxlist_file}",
                    f"images={image_file}",
                    f"expimages={exposure_map}",
                    f"detmasks={detmask_file}",
                    f"bkgimages={bkg_map}",
                    f"srcimages={output_sourceimage}",
                    "extentmodel=gaussian",
                    f"emin={emin}",
                    f"emax={emax}",
                    "srcima_flag=Y"
                    ], stdout=log_file, stderr=log_file)

# Function to run catprep
def run_catprep(input_mllist, out_catfile, log_file=None):
    subprocess.run(["catprep", 
                    f"infile={input_mllist}", 
                    f"outfile={out_catfile}"
                    ], stdout=log_file, stderr=log_file)
    
########## Workflow ##########
logger.info("\n========================================\n")

# Run ermask
logger.info('1) Creating the detection mask (ermask)...')

if os.path.exists(output_mask_file):
    os.remove(output_mask_file)

with open(log_filename, "a") as log_file:
    run_ermask(input_expmap, output_mask_file, log_file=log_file)

with open(log_filename, "r") as log_file:
    log_content = log_file.readlines()
    ermask_count = sum(1 for line in log_content if 'ermask: DONE' in line)
    if ermask_count == 1:
        logger.info(f'Detection mask created successfully as {output_mask_file}')
    else:
        logger.info(f'Error: Detection mask creation failed!')
        exit()

# Run erbox (local)
logger.info("\n========================================\n")
logger.info('2) Running source detection (erbox) in local mode...')
if os.path.exists(output_boxlist_local):
    os.remove(output_boxlist_local)

with open(log_filename, "a") as log_file:
    run_erbox(input_image, input_expmap, output_mask_file, output_boxlist_local, log_file=log_file)

with open(log_filename, "r") as log_file:
    log_content = log_file.readlines()
    erbox_count = sum(1 for line in log_content if 'erbox: DONE' in line)
    if erbox_count == 1:
        logger.info(f'Local mode source detection completed successfully and file saved as {output_boxlist_local}')
    else:
        logger.info(f'Error: Local mode source detection failed!')
        exit()

# Run erbackmap
logger.info("\n========================================\n")
logger.info('3) Creating background map (erbackmap)...')
with open(log_filename, "a") as log_file:
    run_erbackmap(input_image, input_expmap, output_mask_file, output_boxlist_local, output_bkgmap, output_cheesemask, log_file=log_file)

with open(log_filename, "r") as log_file:
    log_content = log_file.readlines()
    erbackmap_count = sum(1 for line in log_content if 'erbackmap: DONE' in line)
    if erbackmap_count == 1:
        logger.info(f'Background map created successfully as {output_bkgmap}')
    else:
        logger.info(f'Error: Background map creation failed!')
        exit()

# Run erbox (map)
logger.info("\n========================================\n")
logger.info('4) Running source detection (erbox) in map mode...')
if os.path.exists(output_boxlist_map):
    os.remove(output_boxlist_map)

with open(log_filename, "a") as log_file:
    run_erbox(input_image, input_expmap, output_mask_file, output_boxlist_map, output_bkgmap, log_file=log_file)

with open(log_filename, "r") as log_file:
    log_content = log_file.readlines()
    erbox_count = sum(1 for line in log_content if 'erbox: DONE' in line)
    if erbox_count == 2:
        logger.info(f'Map mode source detection completed successfully and file saved as {output_boxlist_map}')
    else:
        logger.info(f'Error: Map mode source detection failed!')
        exit()

# Run ermldet
logger.info("\n========================================\n")
logger.info('5) Identifying sources (ermldet)...')
if os.path.exists(output_mllist):
    os.remove(output_mllist)

if os.path.exists(output_sourceimage):
    os.remove(output_sourceimage)

with open(log_filename, "a") as log_file:
    run_ermldet(input_image, input_expmap, output_mask_file, output_boxlist_map, output_bkgmap, output_mllist, output_sourceimage, log_file=log_file)

with open(log_filename, "r") as log_file:
    log_content = log_file.readlines()
    ermldet_count = sum(1 for line in log_content if 'ermldet: DONE' in line)
    if ermldet_count == 1:
        logger.info(f'Source identification completed successfully and file saved as {output_mllist}')
    else:
        logger.info(f'Error: Source identification failed!')
        exit()

# Run catprep
logger.info("\n========================================\n")
logger.info('6) Saving the final catalog...')
if os.path.exists(output_catalog):
    os.remove(output_catalog)

with open(log_filename, "a") as log_file:
    run_catprep(output_mllist, output_catalog, log_file=log_file)

with open(log_filename, "r") as log_file:
    log_content = log_file.readlines()
    catprep_count = sum(1 for line in log_content if 'catprep: DONE' in line)
    if catprep_count == 1:
        logger.info(f'Final catalog saved successfully as {output_catalog}')
    else:
        logger.info('Error: Saving the final catalog failed!')
        exit()

logger.info("\n*All eSASS tasks successfully completed.*")

########## Selecting point sources and creating cheese-mask ##########
logger.info("\n========================================\n")
logger.info('7) Selecting point sources and creating cheese-mask...')

if pts_catalog:
    pts_cat = pts_catalog
else:
    pts_cat = output_catalog

logger.info(f'\nUsing the catalog "{pts_cat}" to select point sources\n')

detmask_file = output_mask_file
cheesemask_file = os.path.join(os.path.dirname(detmask_file), f'cheesemask_PS_{PS_size}arcmin.fits')

hdulist = fits.open(input_image)
ima = hdulist[0].data
prihdr = hdulist[0].header
pix2deg = prihdr['CDELT2']  # deg
xsize, ysize = ima.T.shape  # transpose is required because x is RA and y is DEC

mask_hdu = fits.open(detmask_file)
mask = mask_hdu[0].data

ima_wcs = wcs.WCS(prihdr, relax=False)
ima_racen, ima_deccen = prihdr['CRVAL1'], prihdr['CRVAL2']
ima_r = np.max((xsize, ysize)) / 2 * pix2deg  # deg
ima_coord = SkyCoord(ima_racen * u.deg, ima_deccen * u.deg, frame='icrs')

cat_src = fits.open(pts_cat)[1].data
cat_src = cat_src[(cat_src.EXT == 0) & (cat_src.DET_LIKE_0 > 12)]  # Select high S/N point sources with DET_LIKE>8
coord_src = SkyCoord(cat_src.RA * u.deg, cat_src.DEC * u.deg, frame='icrs')

# Convert RA and DEC of sources to pixel coordinates
pix_coords = ima_wcs.all_world2pix(np.column_stack((cat_src.RA, cat_src.DEC)), 0)
# Only consider pix_coords that are within the image pixel bounds
valid_pix_coords_mask = (pix_coords[:, 0] >= 0) & (pix_coords[:, 0] < (xsize - 1)) & (pix_coords[:, 1] >= 0) & (pix_coords[:, 1] < (ysize - 1))
pix_coords = pix_coords[valid_pix_coords_mask]

# Create a mask to keep only sources with mask value of 1
valid_sources_mask = mask[pix_coords[:, 1].astype(int), pix_coords[:, 0].astype(int)] == 1

# Apply the mask to cat_src
cat_src = cat_src[valid_pix_coords_mask][valid_sources_mask]

ra_src = cat_src.RA
dec_src = cat_src.DEC

# Fix the masking radius to 1arcmin. Needs to be modified for more accurate analysis.
ext_src = np.zeros(len(ra_src)) + (PS_size / 60)

def circle(X, Y):
    x, y = np.meshgrid(X, Y)
    rho = np.sqrt(x * x + y * y)
    return rho

# def process_source(j):
#     pixim = ima_wcs.all_world2pix([[float(ra_src[j]), float(dec_src[j])]], 0)
#     xp = pixim[0][0]
#     yp = pixim[0][1]
#     rho = circle(x - xp, y - yp) * pix2deg
#     ii = np.where(rho <= ext_src[j])
#     if len(ii[0]) > 0:
#         mask[ii] = 0

x = np.arange(xsize)
y = np.arange(ysize)

# with ProcessPoolExecutor() as executor:
#     list(tqdm(executor.map(process_source, range(len(ra_src))), total=len(ra_src)))

for j in tqdm(range(len(ra_src))):
    pixim = ima_wcs.all_world2pix([[float(ra_src[j]), float(dec_src[j])]], 0)
    xp = pixim[0][0]
    yp = pixim[0][1]
    rho = circle(x - xp, y - yp) * pix2deg
    ii = np.where(rho <= ext_src[j])
    if len(ii[0]) > 0:
        mask[ii] = 0

hdu = fits.PrimaryHDU(mask)
hdu.header.update(ima_wcs.to_header())
hdulist = fits.HDUList([hdu])
hdulist.writeto(cheesemask_file, overwrite=True)

output_region_file = os.path.join(output_dir, f'Point_Sources_{PS_size}arcmin.reg')

with open(output_region_file, 'w') as f:
    for i in range(len(ra_src)):
        print(f"fk5; circle({ra_src[i]},{dec_src[i]},{ext_src[i]})", file=f)

logger.info(f'\nCheese-mask saved as {cheesemask_file}')
logger.info(f'Point sources region file saved as {output_region_file}')

end_time = time.time()
time_taken = end_time - start_time

logger.info("\n========================================\n")
if time_taken < 600:
    logger.info(f'** All tasks completed successfully in {time_taken:.2f} seconds **')
if time_taken >= 600:
    logger.info(f'** All tasks completed successfully in {(time_taken/60):.2f} minutes **')
if time_taken >= 3600:
    logger.info(f'** All tasks completed successfully in {(time_taken/3600):.2f} hours **')
logger.info("\n========================================\n")

if open_ds9:
    try:
        ds9_command = f"ds9 {cheesemask_file} -regions {output_region_file} &"
        subprocess.run(ds9_command, shell=True, check=True)
        logger.info(f'DS9 opened with cheese-mask file {cheesemask_file} and regions {output_region_file}.')
    except Exception as e:
        logger.error(f'Failed to open DS9 with error: {e}')